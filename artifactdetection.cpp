// artifactdetection.cpp : implementation file
//

#include "stdafx.h"
#include "EEG_marking_tool.h"
#include "EEG_marking_toolDlg.h"
#include "math.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*
 this is the artifact detection routine.
*/
void CEEG_marking_toolDlg::artifact_detection(int ch_no)
{
	int start_index, end_index;
	int mark_count;
	int inp_sig_len;
	int i,j;

	// allocate memory for the input signal data
	double *input_signal;
	double *aux_inp_signal_wavelet;		// allocation for manipulating wavelet coefficients - to not hamper the original 

	// allocate memory for temporary power spectrum storage
	double *x;
	int nfft;

	// we declare array which stores the length of respective approximate and detail level coefficients
	int len_coeff[LEVEL_OF_DECOMPOSITION + 1];

	// total wavelet coefficient generated power
	// and the subband power related variables
	double total_wavelet_coeff_power;
	double subband_coeff_power[LEVEL_OF_DECOMPOSITION + 1];
	double stdev[LEVEL_OF_DECOMPOSITION + 1];
	double adaptive_thr[LEVEL_OF_DECOMPOSITION + 1];
	int cum_coeff_len;

	// variables for manipulating the subband coefficients generated by wavelet transform
	double *tmp_sig;

	// statistical features
	double kurtosis, abs_volt_sum, total_psd, sef95, peak_amp_var_ratio, hfd;
	double d, max_abs_data, var;

	// test data creation
	// defined already in header file
	/*
	CvMat *mat_test_feat;
	*/

	double test_label;
	
	// pointer to marking database
	struct data_mark_format* temp_data_mark;	

	// loop through all the existing marks
	// the marks can be burst, sleep spindle etc
	temp_data_mark = marking_database[ch_no];

    for (mark_count = 0; mark_count < mark_database_count[ch_no]; mark_count++)
	{
		// skip the mark where start time is invalid
		// or if there is a suppression mark
		if ((temp_data_mark->mark_start_time == -1) || 
			(temp_data_mark->mark_event == SUPPRESSION_MARK) ||
			(temp_data_mark->mark_event == BURST_SUPPRESSION_MARK))
		{
			temp_data_mark = temp_data_mark->next;
			continue;
		}
		// define the segment boundaries
		start_index = (int) floor(temp_data_mark->mark_start_time * sampling_rate);
		end_index = (int) floor(temp_data_mark->mark_end_time * sampling_rate) - 1;
		if (end_index >= channel_data_size)
			end_index = (channel_data_size - 1);
	
		// allocate input signal  
		inp_sig_len = (end_index - start_index + 1);
		input_signal = (double *) calloc(inp_sig_len, sizeof(double));	

		// allocate auxiliary input signal for wavelet decomposition
		aux_inp_signal_wavelet = (double *) calloc(inp_sig_len, sizeof(double));	

		// read the signal segment
		Read_Signal_Segment(ch_no, start_index, end_index, input_signal, inp_sig_len, false);

		// determine nfft
		nfft = (int)(pow(2, (int)ceil(log(sampling_rate) / log(2))) * TIME_WINDOW_LENGTH);	

		// auxiliary storage for calculation of fourier transform
		x = (double *) calloc((2 * nfft), sizeof(double));	

		// fill the auxiliary array structures
		for (i = 0; i < nfft; i++)
		{
			if (i < inp_sig_len)
			{
				aux_inp_signal_wavelet[i] = input_signal[i];	// wavelet coefficients
				x[2 * i] = input_signal[i];		// fill the real part of the data		
			}
			else
				x[2 * i] = 0;	//fill with 0

			// fill imaginary part of the signal
			x[2 * i + 1] = 0;	
		}

		//////////////////////////////
		// feature extraction step

		// now we call the wavelet transform
		for (i = 0; i <= LEVEL_OF_DECOMPOSITION; i++)
			len_coeff[i] = 0;

		// wavelet transform of the input signal
		// coiflet 3 wavelet is used
		// we use the auxiliary storage for wavelet decomposition
		wtr_fwd_coif3(aux_inp_signal_wavelet, inp_sig_len, len_coeff);

		// initialize wavelet transform based power variables
		for (j = 0; j < (LEVEL_OF_DECOMPOSITION + 1); j++)
			subband_coeff_power[j] = 0;

		// calculate total wavelet coefficients' power 
		total_wavelet_coeff_power = 0;
		for (i = 0; i < inp_sig_len; i++)
			total_wavelet_coeff_power += pow(aux_inp_signal_wavelet[i], 2);			

		// now process the subband coefficients generated by wavelet transform mechanism
		cum_coeff_len = 0;

		for (j = 0; j < (LEVEL_OF_DECOMPOSITION + 1); j++)
		{
			// allocate temporary data for getting the subband coefficients
			tmp_sig = (double *) calloc(len_coeff[j], sizeof(double));	
			for (i = cum_coeff_len; i < (cum_coeff_len + len_coeff[j]); i++)
				tmp_sig[i - cum_coeff_len] = aux_inp_signal_wavelet[i];

			// calculate power of coefficients
			for (i = 0; i < len_coeff[j]; i++)
			{
				subband_coeff_power[j] += pow(tmp_sig[i], 2);			
				
			}
			// calculate normalized subband power - feature 7 to 12
			subband_coeff_power[j] /= total_wavelet_coeff_power;

			// feature 13 to 18 - standard deviation of wavelet subband coefficients
			stdev[j] = sqrt(ComputeVar(tmp_sig, len_coeff[j]));		

			// calulate adaptive threshold based on stein's unbiased risk estimator
			// thresholds are calculated using coefficients of each decomposition level
			// feature 1 to 6
			adaptive_thr[j] = calc_rigsure_thrs(tmp_sig, len_coeff[j]);

			free(tmp_sig);	// free temp data

			cum_coeff_len += len_coeff[j];	// update cumulative length of coefficients covered
		}	// end of wavelet subband processing loop

		// now compute some statistical feature by using input data segment
		// higuchi fractal dimension - feature 19
		hfd = ComputeHiguchiFD(input_signal, inp_sig_len);	

		// kurtosis - feature 21
		kurtosis = ComputeKurt(input_signal, inp_sig_len);

		// mean absolute voltage - feature 22
		abs_volt_sum = ComputeMeanAbsVolt(input_signal, inp_sig_len);

		// SEF95 - feature 23
		d = nfft * nfft * 1.0;	// divider in PSD estimate
		DeriveFFT(x, nfft);
		total_psd = ComputePSD(x, nfft, d);
		sef95 = ComputeSEF95(x, sampling_rate, nfft, d, total_psd);
 
		// peak amplitude to variance ratio - feature 25
		max_abs_data = 0;
		for (i = 0; i < inp_sig_len; i++)
		{
			if (fabs(input_signal[i]) > max_abs_data)
				max_abs_data = fabs(input_signal[i]);
		}
		var = ComputeVar(input_signal, inp_sig_len);
		peak_amp_var_ratio = max_abs_data / var;
		
		// free the temporary storage
		free(aux_inp_signal_wavelet);
		free(x);
		free(input_signal);
		///////////////////////////////////////////////
		// now we have to call the classifiers for classifying the marks
# if 1
		// create the test sample
		// allocated already in calling function
		//mat_test_feat = cvCreateMat(1, no_of_feature_artifact_detection, CV_32FC1);


		mat_test_feat_artifact->data.fl[0] = subband_coeff_power[0];
		mat_test_feat_artifact->data.fl[1] = stdev[0];
		mat_test_feat_artifact->data.fl[2] = stdev[1];
		mat_test_feat_artifact->data.fl[3] = stdev[2];
		mat_test_feat_artifact->data.fl[4] = hfd;
		mat_test_feat_artifact->data.fl[5] = kurtosis;
		mat_test_feat_artifact->data.fl[6] = abs_volt_sum;
		mat_test_feat_artifact->data.fl[7] = sef95;
		mat_test_feat_artifact->data.fl[8] = peak_amp_var_ratio;
# endif

		///////////////////////////////

		// predict the sample
		test_label = svm_classifier_artifact_detection->predict(mat_test_feat_artifact);
	
		if (test_label == 1)
			temp_data_mark->mark_event = ARTIFACT_MARK;
		else 
			temp_data_mark->mark_event = BURST_MARK;

		// advance the node pointer
		temp_data_mark = temp_data_mark->next;

	}	// end of mark loop
	
}	// end artifact detection routine
